% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/module3_ata.R
\name{ata}
\alias{ata}
\alias{ata_constraint}
\alias{ata_get_items}
\alias{ata_item_enemy}
\alias{ata_item_fixedvalue}
\alias{ata_item_maxselect}
\alias{ata_obj_absolute}
\alias{ata_obj_relative}
\alias{ata_solve}
\alias{plot.ata}
\alias{print.ata}
\title{Automated Test Assembly (ATA)}
\usage{
ata(pool, nform = 1, len = NULL, maxselect = NULL, debug = FALSE)

\method{print}{ata}(x, ...)

\method{plot}{ata}(x, ...)

ata_obj_relative(x, coef, mode, negative = FALSE, flatten = NULL,
  compensate = FALSE, forms = NULL, collapse = FALSE)

ata_obj_absolute(x, coef, target, compensate = FALSE, forms = NULL,
  collapse = FALSE)

ata_constraint(x, coef, min = NA, max = NA, level = NULL, forms = NULL,
  collapse = FALSE)

ata_item_maxselect(x, maxselect, items = NULL)

ata_item_enemy(x, items)

ata_item_fixedvalue(x, items, min, max, forms = NULL, collapse = FALSE)

ata_solve(x, ...)

ata_get_items(x, as.list = FALSE)
}
\arguments{
\item{pool}{a data frame of item parameters}

\item{nform}{the number of forms to be assembled}

\item{len}{the test length}

\item{maxselect}{the maximum selection of each item}

\item{debug}{\code{TRUE} to turn on debugging mode}

\item{x}{the ata object}

\item{...}{further arguments}

\item{coef}{the coefficients added to the LP}

\item{mode}{the optimzation mode. 'max' for maximization and 'min' for minimization}

\item{negative}{\code{TRUE} when the expected value of the objective function is negative}

\item{flatten}{the flatten parameter to make the objective function smooth}

\item{compensate}{\code{TRUE} when objective functions are compensatory to one another}

\item{forms}{the forms to which objectives are added. \code{NULL} for all forms}

\item{collapse}{\code{TRUE} to collapse all forms into one objective}

\item{target}{the targeted value of the objective function}

\item{min}{the minimum value of the constraint}

\item{max}{the maximum value of the constraint}

\item{level}{the level value for categorical variable}

\item{items}{a vector of item index}

\item{as.list}{\code{TRUE} to return a list, \code{FALSE} to return a data frame}
}
\description{
\code{ata} creates an \code{ata} object

\code{ata_obj_relative} adds relative (maximize/minimize) objectives to LP

\code{ata_obj_absolute} adds absolute objectives to LP

\code{ata_constraint} adds a constraint to LP

\code{ata_item_maxselect} sets the maximum selection for items

\code{ata_item_enemy} adds enemy item relationship to LP

\code{ata_item_fixedvalue} sets a fixed value range for items

\code{ata_solve} solves the LP

\code{ata_get_items} extracts items using assembly results
}
\details{
An \code{ata} object contains an item pool (\code{pool}), a LP object (\code{lp}),
and several constants such as the number of forms (\code{nform}), the size of item pool(\code{nitem}), 
the size of LP object (\code{nlpitem}), etc. It would also contain assembly results (\code{result}) 
if LP has been solved. The result is a data frame of binary code with 1 meaning an item being selected 
(items in rows and forms in columns). Use \code{ata_get_items} to extract selected items from results. \cr

When \code{coef} is a pool-size numeric vector, coefficients are used directly.
When \code{coef} is a variable name, variable values are used as coefficients.
When \code{coef} is a numeric vector unequal to pool size, information at those points are used as coefficients.\cr

When the expected value of the objective function is negative, set the \code{negative=TRUE}.\cr

The \code{compensate} argument controls whether objective functions are compensatory. 
For example, the ATA job wants to maximize information at -0.5 and 0.5.
When \code{compensate=TRUE}, the LP assembles a test maximizing the sum of information at -0.5 and 0.5.
When \code{compensate=FALSE}, the LP assembles a test maximizing information at each point, but not necessarily a maxmized total.\cr

\code{ata_obj_relative} is to maximize or minimize the objectives. There are four scenarios.
(1) For a maximization job with postive expected value, maximize y while sum(x) - y >= 0 and <= F (flatten).
(2) For a maximization job with negative expected value, minimize y while sum(x) + y >= 0 and <= F.
(3) For a minimization job with postive expected value, minimize y while sum(x) + y <= 0 and >= F.
(4) For a minimization job with negative expected value, maximize y while sum(x) - y <= 0 and >= F.

\code{ata_obj_absolute} minimizes y while sum(x) + y >= target and sum(x) - y <= target. \cr

For \code{ata_constraint}, set \code{coef} to a variable name 
in the pool and \code{level} a level value of that variable to 
add a categorical constraint. Set \code{coef} to a variable name and
leave \code{level} to default value (\code{NULL} or \code{NA}) to add
a quantitative constraint. Set \code{coef} to a number or a vector to 
add a constraint directly.\cr

In \code{ata_solve}, the \code{...} are additional \code{lp.control.options}.
}
\examples{
\dontrun{
# generate a 100-item pool
# library(magrittr)
# library(dplyr)
items <- irt_model("3pl")$gendata(1, 100)$items
items$content <- sample(1:3, nrow(items), replace=TRUE)
items$time <- round(rlnorm(nrow(items), log(60), .2), 0)
# ex. 1: 4 forms, 10 items, maximize b parmaters
x <- ata(items, 4, len=10, maxselect=1)
x <- ata_obj_relative(x, "b", "max")
x <- ata_solve(x)
plot(x)
ata_get_items(x) \%>\% group_by(form) \%>\% 
  summarize(a=mean(a), b=mean(b), c=mean(c))
# ex. 2: 4 forms, 10 items, minimize b parmaeters
x <- ata(items, 4, len=10, maxselect=1)
x <- ata_obj_relative(x, "b", "min", negative=TRUE)
x <- ata_solve(x)
plot(x)
ata_get_items(x) \%>\% group_by(form) \%>\% 
  summarize(a=mean(a), b=mean(b), c=mean(c))
# ex. 3: 4 forms, 10 items, maximize information at -1 and 1
# content distribution: 3, 3, 4; response time: avg. 55--65s
x <- ata(items, 4, len=10, maxselect=1) \%>\%
     ata_obj_relative(c(-1, 1), "max") \%>\%
     ata_constraint("content", min=3, max=3, level=1) \%>\%
     ata_constraint("content", min=3, max=3, level=2) \%>\%
     ata_constraint("content", min=4, max=4, level=3) \%>\%
     ata_constraint("time", min=55*10, max=65*10) \%>\%
     ata_solve()
plot(x)
ata_get_items(x) \%>\% group_by(form) \%>\% 
  summarize(a=mean(a), b=mean(b), c=mean(c),
  cont1=sum(content==1), cont2=sum(content==2), cont3=sum(content==3))
# ex. 4: 2 forms, 10 items, mean(b) = 0, sd(b) = 1.0, content = (3, 3, 4)
x <- ata(items, 2, len=10, maxselect=1) \%>\%
     ata_obj_absolute(x$pool$b, 0 * 10) \%>\%
     ata_obj_absolute((x$pool$b - 0)^2, 1 * 10) \%>\%
     ata_constraint("content", min=3, max=3, level=1) \%>\%
     ata_constraint("content", min=3, max=3, level=2) \%>\%
     ata_constraint("content", min=4, max=4, level=3) \%>\%
     ata_solve(timeout=30)
plot(x)
ata_get_items(x) \%>\% group_by(form) \%>\% 
  summarize(b_mean=mean(b), b_sd=sd(b),
  cont1=sum(content==1), cont2=sum(content==2), cont3=sum(content==3))
# ex. 5: 2 forms, 10 items, flat TIF over [-1, 1]
x <- ata(items, 2, len=10, maxselect=1) \%>\%
     ata_obj_relative(seq(-1, 1, .5), "max", flatten=0.1) \%>\%
     ata_solve(timeout=30)
plot(x)
}
}

